[
  {
    "id": "concept1",
    "name": "Dictionary Views (keys, values, items)",
    "shortDescription": "Dictionary view objects provide dynamic, lightweight access to a dictionary's keys, values, or key-value pairs.",
    "description": "Dictionary views are dynamic collections that offer a window into a dictionary's contents without creating a separate copy of the data. The `dict.keys()` method returns a view of all keys, `dict.values()` returns a view of all values, and `dict.items()` returns a view of all key-value pairs as tuples. A key characteristic of these views is their 'live' nature: they reflect any changes made to the underlying dictionary immediately. This makes them highly memory-efficient, especially for large dictionaries, as they don't duplicate the data. These view objects also support set-like operations (for `keys()` and `items()`) such as union, intersection, and difference, making them powerful for comparing dictionary structures.",
    "tags": ["dict", "view", "keys", "values", "items", "iterator", "performance", "memory"],
    "difficulty": "beginner",
    "examples": [
      "my_config = {'theme': 'dark', 'font_size': 14}\nall_keys = my_config.keys()\nprint(f'Keys: {list(all_keys)}')\n\nmy_config['language'] = 'en'\nprint(f'Keys after change: {list(all_keys)}')",
      "product_prices = {'apple': 1.0, 'banana': 0.5, 'orange': 1.2}\nall_values = product_prices.values()\nprint(f'Values: {list(all_values)}')\n\nall_items = product_prices.items()\nprint(f'Items: {list(all_items)}')"
    ],
    "sub_concepts": [
      {
        "id": "sub_concept11",
        "name": "Dictionary Keys View",
        "shortDescription": "The `dict.keys()` method provides a dynamic view of all keys in a dictionary.",
        "description": "The `dict.keys()` method returns a **dictionary view object** that displays a list of all the keys in the dictionary. This view is 'live,' meaning if the dictionary changes (e.g., a new key-value pair is added or an existing one is deleted), the `keys()` view will automatically reflect these changes without needing to be re-called. It behaves like a set for most operations, allowing for efficient membership testing (`key in dict_view`) and set-like operations like union, intersection, and difference with other key views or sets. This makes it efficient for iterating over keys or performing set-based comparisons.",
        "tags": ["dict", "view", "keys", "iterator", "set", "performance"],
        "difficulty": "beginner",
        "examples": [
          "student_scores = {'Alice': 95, 'Bob': 88}\nstudent_names = student_scores.keys()\nprint(f'Students: {list(student_names)}')\n\nstudent_scores['Charlie'] = 92\nprint(f'Updated Students: {list(student_names)}')",
          "inventory_a = {'pen': 10, 'paper': 5}\ninventory_b = {'pencil': 8, 'pen': 12}\ncommon_items = inventory_a.keys() & inventory_b.keys()\nprint(f'Common items in both inventories: {list(common_items)}')"
        ]
      },
      {
        "id": "sub_concept12",
        "name": "Dictionary Values View",
        "shortDescription": "The `dict.values()` method returns a dynamic view of all values in a dictionary.",
        "description": "The `dict.values()` method provides a **dictionary view object** that shows all the values currently in the dictionary. Similar to the keys view, this view is dynamic and will update automatically as the underlying dictionary is modified. Unlike `keys()` views, `values()` views do not necessarily contain unique elements and do not support set-like operations, as values can be duplicated. They are primarily used for iterating over the values or checking for value membership, offering a memory-efficient way to access all data values without creating a duplicate list.",
        "tags": ["dict", "view", "values", "iterator", "performance"],
        "difficulty": "beginner",
        "examples": [
          "city_populations = {'NY': 8_000_000, 'LA': 4_000_000}\npopulations = city_populations.values()\nprint(f'Populations: {list(populations)}')\n\ncity_populations['Chicago'] = 2_700_000\nprint(f'Updated Populations: {list(populations)}')",
          "sensor_readings = {'temp_c': 22.5, 'humidity': 60.1, 'pressure_kpa': 101.2}\nall_reading_values = sensor_readings.values()\nprint(f'All readings: {list(all_reading_values)}')\nprint(f'Is 60.1 a reading? {60.1 in all_reading_values}')"
        ]
      },
      {
        "id": "sub_concept13",
        "name": "Dictionary Items View",
        "shortDescription": "The `dict.items()` method offers a dynamic view of key-value pairs as tuples.",
        "description": "The `dict.items()` method returns a **dictionary view object** that displays each key-value pair as a tuple (key, value). This view is also dynamic and will reflect any additions, deletions, or modifications to the original dictionary. The `items()` view supports efficient iteration over both keys and values simultaneously, making it ideal for loops that need to access both components of each entry. Like the `keys()` view, it supports set-like operations (union, intersection, difference) due to the uniqueness of key-value tuples, which can be highly useful for comparing the exact contents of dictionaries.",
        "tags": ["dict", "view", "items", "iterator", "tuple", "set", "performance"],
        "difficulty": "beginner",
        "examples": [
          "user_profile = {'id': 101, 'username': 'user_alpha'}\nprofile_items = user_profile.items()\nprint(f'Profile items: {list(profile_items)}')\n\nuser_profile['email'] = 'alpha@example.com'\nprint(f'Updated profile items: {list(profile_items)}')",
          "set_a = {'a': 1, 'b': 2}.items()\nset_b = {'b': 2, 'c': 3}.items()\ncommon_pairs = set_a & set_b\nprint(f'Common key-value pairs: {list(common_pairs)}')\n\nfor key, value in {'x': 10, 'y': 20}.items():\n    print(f'Key: {key}, Value: {value}')"
        ]
      }
    ]
  },
  {
    "id": "concept2",
    "name": "Collection Inspection and Modification",
    "shortDescription": "This covers fundamental operations for querying and modifying common Python collections like lists, dictionaries, sets, and strings.",
    "description": "Python provides a rich set of built-in functions and methods for interacting with its core collection data types. These operations allow developers to determine the size of a collection, count element occurrences, find element positions, and dynamically add or remove elements. Understanding these fundamental operations is crucial for efficient data management and manipulation. Many of these functions and methods offer efficient implementations, typically with average O(1) or O(n) time complexity, depending on the operation and underlying data structure. Proper use of these built-in tools contributes to writing concise, readable, and performant Python code.",
    "tags": ["collection", "list", "dict", "set", "string", "int", "method", "function", "performance", "builtin"],
    "difficulty": "intermediate",
    "examples": [
      "data_list = [10, 20, 30, 20]\nprint(f'Length: {len(data_list)}')\nprint(f'Count of 20: {data_list.count(20)}')\n\ndata_list.append(40)\nprint(f'After append: {data_list}')",
      "my_sentence = 'hello world'\nprint(f'Length of sentence: {len(my_sentence)}')\n\nshopping_cart = {'milk', 'bread', 'eggs'}\nshopping_cart.remove('bread')\nprint(f'Cart after removing bread: {shopping_cart}')"
    ],
    "sub_concepts": [
      {
        "id": "sub_concept21",
        "name": "Determining Collection Size (len)",
        "shortDescription": "The `len()` built-in function returns the number of items in a collection.",
        "description": "The **`len()`** built-in function is used to get the number of items (length) of an object. It works universally across various sequence and collection types, including **lists**, **tuples**, **dictionaries**, **sets**, and **strings**. For sequences like lists and strings, it returns the number of elements. For dictionaries and sets, it returns the number of key-value pairs or unique elements, respectively. This operation is generally very efficient, often O(1), as many collection types store their size internally.",
        "tags": ["len", "function", "builtin", "list", "dict", "set", "string", "performance"],
        "difficulty": "beginner",
        "examples": [
          "my_list = [1, 2, 3, 4, 5]\nprint(f'Number of items in list: {len(my_list)}')",
          "my_dict = {'a': 1, 'b': 2}\nprint(f'Number of key-value pairs in dict: {len(my_dict)}')",
          "my_set = {1, 2, 3}\nprint(f'Number of elements in set: {len(my_set)}')",
          "my_string = 'Python'\nprint(f'Length of string: {len(my_string)}')"
        ]
      },
      {
        "id": "sub_concept22",
        "name": "Counting Element Occurrences (count and in operator)",
        "shortDescription": "Methods like `count()` and the `in` operator are used to check for element presence or frequency.",
        "description": "To determine how many times a specific element appears in a **list** or **string**, the **`.count()`** method is employed. It iterates through the collection and returns the number of non-overlapping occurrences of the specified element. For simply checking if an element exists within a collection, the **`in` operator** (e.g., `if <el> in <collection>:`) is highly efficient and Pythonic. The `in` operator works across **lists**, **tuples**, **sets**, **dictionaries** (checking keys), and **strings**. While `count()` iterates through the entire collection (O(n)), the `in` operator can be O(1) for sets and dictionaries on average due to their hash-based nature, offering a significant performance advantage for membership testing.",
        "tags": ["count", "operator", "in", "list", "string", "dict", "set", "performance", "boolean"],
        "difficulty": "intermediate",
        "examples": [
          "numbers = [1, 2, 2, 3, 2]\nprint(f'Occurrences of 2: {numbers.count(2)}')",
          "sentence = 'apple banana apple'\nprint(f'Occurrences of \"apple\": {sentence.count(\"apple\")}')",
          "users = {'Alice', 'Bob', 'Charlie'}\nif 'Bob' in users:\n    print('Bob is in the set')",
          "config = {'debug': True, 'port': 8080}\nif 'port' in config:\n    print('Port is configured')"
        ]
      },
      {
        "id": "sub_concept23",
        "name": "Finding Element Index (index)",
        "shortDescription": "The `index()` method returns the first occurrence of an element in a list or string.",
        "description": "The **`.index()`** method is available for **lists** and **strings** to find the position (index) of the first occurrence of a specified element. It returns an integer representing the zero-based index of the element. If the element is not found within the collection, a **`ValueError`** is raised. Developers should use this method when the position of an element is needed and should typically wrap calls in a `try-except` block or precede with an `in` check if the element's presence is uncertain, to prevent runtime errors.",
        "tags": ["index", "method", "list", "string", "exception", "ValueError"],
        "difficulty": "beginner",
        "examples": [
          "letters = ['a', 'b', 'c', 'b']\nprint(f'Index of first \"b\": {letters.index(\"b\")}')",
          "word = 'programming'\nprint(f'Index of first \"g\": {word.index(\"g\")}')",
          "try:\n    numbers = [10, 20, 30]\n    print(numbers.index(40))\nexcept ValueError:\n    print('40 not found in list.')"
        ]
      },
      {
        "id": "sub_concept24",
        "name": "Removing Elements (pop, remove, clear)",
        "shortDescription": "Various methods are used to remove elements from mutable collections, either by index, value, or entirely.",
        "description": "Mutable collections like **lists**, **dictionaries**, and **sets** provide methods for removing elements. The **`.pop()`** method for lists removes and returns an item, by default the last one, or by a specified index. For dictionaries, `pop()` removes and returns a key-value pair. The **`.remove()`** method for lists and sets removes the first occurrence of a specified *value*. If the value is not found, `remove()` raises a **`ValueError`**. Finally, the **`.clear()`** method efficiently removes all items from a **list**, **dictionary**, or **set**, leaving the collection empty. Each method serves a specific removal use case, impacting the collection in-place.",
        "tags": ["remove", "pop", "clear", "method", "list", "dict", "set", "mutable", "in-place", "exception", "ValueError"],
        "difficulty": "beginner",
        "examples": [
          "my_stack = [1, 2, 3]\nlast_item = my_stack.pop()\nprint(f'Popped: {last_item}, List: {my_stack}')",
          "my_queue = ['A', 'B', 'C']\nmy_queue.pop(0)\nprint(f'After popping first: {my_queue}')",
          "my_set = {'apple', 'banana', 'cherry'}\nmy_set.remove('banana')\nprint(f'Set after removing banana: {my_set}')",
          "data_storage = {'key1': 'value1', 'key2': 'value2'}\ndata_storage.clear()\nprint(f'Storage after clearing: {data_storage}')"
        ]
      },
      {
        "id": "sub_concept25",
        "name": "Inserting Elements (insert)",
        "shortDescription": "The `insert()` method adds an element to a list at a specific index.",
        "description": "The **`.insert(index, element)`** method is a **list**-specific operation used to add an element at a specified position. Unlike `append()`, which adds to the end, `insert()` places the `element` at the given `index`, shifting all subsequent elements to the right. This means that inserting at index `0` will add the element to the beginning of the list. While flexible, frequent insertions at the beginning or middle of large lists can be less performant (O(n)) compared to `append()` due to the need to shift existing elements in memory.",
        "tags": ["insert", "method", "list", "in-place", "performance"],
        "difficulty": "beginner",
        "examples": [
          "numbers = [1, 2, 4]\nnumbers.insert(2, 3)\nprint(f'List after insert: {numbers}')",
          "playlist = ['Song A', 'Song C']\nplaylist.insert(0, 'Song Z')\nprint(f'Playlist with new first song: {playlist}')",
          "alphabets = ['a', 'c', 'd']\nalphabets.insert(1, 'b')\nprint(f'Alphabets after inserting b: {alphabets}')"
        ]
      }
    ]
  },
  {
    "id": "concept3",
    "name": "Date and Time Objects (datetime module)",
    "shortDescription": "The `datetime` module provides classes for working with dates, times, datetimes, and time differences in Python.",
    "description": "Python's built-in **`datetime` module** offers powerful and flexible classes for managing date and time information. This module allows you to represent specific points in time (date and datetime objects), durations (timedelta objects), and just time-of-day information (time objects). These classes handle complexities like leap years and timezone information, providing robust tools for applications requiring precise temporal calculations. The module is part of Python's standard library, making it readily available for all projects without external dependencies. Using these structured objects promotes readability and reduces errors compared to manually handling date/time components.",
    "tags": ["datetime", "date", "time", "timedelta", "module", "standard library", "builtin", "object"],
    "difficulty": "beginner",
    "examples": [
      "from datetime import date, time, datetime, timedelta\n\n# Create a specific date\ntoday = date(2023, 10, 26)\nprint(f'Today: {today}')\n\n# Create a specific time\nmeeting_time = time(hour=14, minute=30)\nprint(f'Meeting Time: {meeting_time}')\n\n# Combine date and time\nmeeting_datetime = datetime(2023, 10, 26, 14, 30)\nprint(f'Meeting Datetime: {meeting_datetime}')\n\n# Calculate a future date\ntomorrow = today + timedelta(days=1)\nprint(f'Tomorrow: {tomorrow}')",
      "from datetime import date, datetime, timedelta\n\n# Current date and time\nnow = datetime.now()\nprint(f'Current time: {now}')\n\n# Date of birth and age calculation\ndob = date(1990, 5, 15)\ncurrent_date = date.today()\nage_in_days = current_date - dob\nprint(f'Age in days: {age_in_days.days}')\n\n# Duration for a task\ntask_duration = timedelta(hours=2, minutes=45)\nprint(f'Task duration: {task_duration}')"
    ],
    "sub_concepts": [
      {
        "id": "sub_concept31",
        "name": "Date Objects (date)",
        "shortDescription": "A **`date`** object represents a calendar date (year, month, day) without time information.",
        "description": "The **`date` class** from the **`datetime` module** represents a calendar date. You create a `date` object by providing the `year`, `month`, and `day` as arguments, for example, `date(2023, 1, 15)`. These objects support valid dates from year 1 to 9999 AD. `date` objects are immutable, meaning their values cannot be changed after creation. They are useful for storing and manipulating date-only information, such as birthdays or significant calendar events. You can perform arithmetic operations with `timedelta` objects to add or subtract days, weeks, etc.",
        "tags": ["date", "datetime", "object", "immutable"],
        "difficulty": "beginner",
        "examples": [
          "from datetime import date\n\n# Create a date object for a specific day\nd_day = date(1947, 8, 15)\nprint(f'Independence Day: {d_day}')\n\n# Get the current local date\ntoday = date.today()\nprint(f'Today\\'s date: {today}')",
          "from datetime import date, timedelta\n\n# Calculate a date 7 days from now\nfuture_date = date.today() + timedelta(days=7)\nprint(f'Date in one week: {future_date}')"
        ]
      },
      {
        "id": "sub_concept32",
        "name": "Time Objects (time)",
        "shortDescription": "A **`time`** object represents a specific time of day (hour, minute, second) without date information.",
        "description": "The **`time` class** within the **`datetime` module** focuses solely on time of day. You instantiate a `time` object by providing `hour`, `minute`, and `second` as keyword arguments, like `time(hour=9, minute=30, second=0)`. Optional arguments include `microsecond`, `tzinfo` (timezone information), and `fold`. Like `date` objects, `time` objects are immutable. They are ideal for representing recurring times, such as meeting schedules or alarm times, independent of a specific calendar date. Operations directly on `time` objects are limited, but they can be combined with `date` objects to form `datetime` objects.",
        "tags": ["time", "datetime", "object", "immutable"],
        "difficulty": "beginner",
        "examples": [
          "from datetime import time\n\n# Create a time object\nwakeup_time = time(hour=7, minute=0, second=0)\nprint(f'Wake-up time: {wakeup_time}')\n\n# Create a time with microseconds\nexact_moment = time(12, 30, 45, 123456)\nprint(f'Exact moment: {exact_moment}')",
          "from datetime import time\n\n# Check if a time is within a certain hour\nearly_morning = time(hour=6, minute=15)\nif early_morning.hour < 8:\n    print('It\\'s still early!')"
        ]
      },
      {
        "id": "sub_concept33",
        "name": "Datetime Objects (datetime)",
        "shortDescription": "A **`datetime`** object combines both date and time information into a single entity.",
        "description": "The **`datetime` class** from the **`datetime` module** is the most comprehensive, representing a specific point in time that includes both date (year, month, day) and time (hour, minute, second, microsecond) components. It is created by providing all necessary components, for example, `datetime(2023, 10, 26, 15, 30, 0)`. `datetime` objects also support optional `tzinfo` and `fold` arguments for timezone handling. They are immutable and are widely used for timestamping events, scheduling, and performing complex temporal calculations, including comparisons and arithmetic with `timedelta` objects.",
        "tags": ["datetime", "date", "time", "object", "immutable"],
        "difficulty": "beginner",
        "examples": [
          "from datetime import datetime\n\n# Create a datetime object for a specific event\nevent_start = datetime(2024, 1, 1, 9, 0, 0)\nprint(f'Event starts: {event_start}')\n\n# Get the current local datetime\ncurrent_moment = datetime.now()\nprint(f'Current moment: {current_moment}')",
          "from datetime import datetime, timedelta\n\n# Calculate a point in time 3 hours from now\nfuture_moment = datetime.now() + timedelta(hours=3)\nprint(f'Future moment: {future_moment}')\n\n# Compare two datetimes\nif event_start < current_moment:\n    print('Event has already passed.')"
        ]
      },
      {
        "id": "sub_concept34",
        "name": "Timedelta Objects (timedelta)",
        "shortDescription": "A **`timedelta`** object represents a duration or difference between two `date` or `datetime` objects.",
        "description": "The **`timedelta` class** from the **`datetime` module** represents a duration, which is a difference between two dates, times, or datetimes. You create `timedelta` objects by specifying units like `weeks`, `days`, `hours`, `minutes`, `seconds`, or `microseconds`. For instance, `timedelta(days=7)` represents one week. These objects are primarily used to perform arithmetic operations with `date` and `datetime` objects, allowing you to easily add or subtract periods of time. They are crucial for calculations involving time differences, such as calculating elapsed time or predicting future dates.",
        "tags": ["timedelta", "datetime", "duration", "calculation", "object"],
        "difficulty": "beginner",
        "examples": [
          "from datetime import timedelta, date\n\n# Create a timedelta for 5 days\nfive_days = timedelta(days=5)\nprint(f'5 days duration: {five_days}')\n\n# Add 5 days to today's date\nfuture_date = date.today() + five_days\nprint(f'Date after 5 days: {future_date}')",
          "from datetime import datetime, timedelta\n\n# Calculate time difference between two datetimes\nstart_time = datetime(2023, 1, 1, 10, 0, 0)\nend_time = datetime(2023, 1, 1, 11, 30, 0)\nelapsed_time = end_time - start_time\nprint(f'Elapsed time: {elapsed_time}')\nprint(f'Elapsed seconds: {elapsed_time.total_seconds()}')"
        ]
      }
    ]
  }
]
